/*证明：
首先对一个森林F = { F1，F2，F3，...，Fn }进行先序遍历（对其中每一个树进行先序遍历）

现在不妨假设有一个森林F = { F1，F2，F3，F4，...，Fn }
合并为一个树T的时候，T的根节点就是对应二叉树中F1的根节点，剩余新的一个森林F* = { F2，F3，F4，...，Fn }作为T的左子树，F1的左孩子为T根节点的左孩子。
F1的右孩子是其左孩子的右孩子。对T进行一个先序遍历，Root->RightChild->LeftChild
LeftChild其实就是新的一个森林F* = { F2，F3，F4,F5,...,Fn }，对右孩子遍历就是对F*遍历。
又因为：
T.root = F1.root,
T.R1 = F1.R1,
T.R2 = F1.R2, T.L2 = F1.L1
...
T.Rn = F1.Rn, T.Ln = F1.L(n - 1)
T.Rn.L(n + 1) = F1.Ln
那么显然他的先序遍历和之前的F1的先序遍历的等价的，Root->RightChild的遍历就是一个对F1的遍历。

即T.root->T.RightChild就是F1的先序遍历，而T.leftchild就是对F*的先序遍历
而F*的先序遍历就是同样的过程，先是对F2的先序遍历，然后是对减去F2的森林的先序遍历
...
即森林的先序遍历等价于分别对其相应二叉树F1~Fn的先序遍历。
*/

void main()
{
	while (1);
}