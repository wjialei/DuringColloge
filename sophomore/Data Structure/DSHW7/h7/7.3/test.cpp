/*

（2）证明题。
（a）证明：如果输入表是有序的，那么QuickSort算法需要O（n^2）的时间。
（b）证明QuickSort在最坏情况下的时间复杂度是O（n^2）。
（c）QuickSort当中为什么要有list[left]<=list[right+1]这句话？

（a）如果是有序表，且已经是顺序，则i到每处都必须停顿，所以总时间为每次循环内有n次循环，所以时间复杂度为O（n*n）;若是恰巧倒序，则j到每处都停顿，情况相类似。
（b）Tworst(n) <= cn + Tworst(n-1)
			 <= cn + c(n-1)+Tworst(n-2)
			  …
			 <= (c1+c2+…+cn) + Tworst(0) = cn(n+1)/2+d = O(n^2).
（c）个人认为是因为快速排序是从i的LEFT端方向挑选枢轴而非j端，所以假设list[left]<=list[right+1]是参照物合乎道理。
（5）快速排序是不稳定的。给出一个例子，其中关键字相同的记录的互相顺序在排序后发生了变化。
	答: 当输入{9A，8，7，6，5，4，3，9B，1}时，结果应为{1，3，4，5，6，7，8，9B，9A}。	
		因为本来9A在9B前面，但经过排序后9B在9A前面，所以快速排序是不稳定的。

*/



void main()
{
	while (1);
}